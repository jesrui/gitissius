set timeout 30

# regexp for the issue id
set Id {[0-9a-f]{64}}
# regexp that match any number of consecutive ANSI color escape sequences from colorama
set C {(?:\e\[[0-9;]*m)*}

# Expect block for `git issius add` and `git issius edit`.
# Execute an `add` command if issue_id is empty, `edit` if it is not empty.
# myiss is a reference to the values to be entered for the issue.
# myshow is a reference to the values expected to be prompted by the command.
# If successful, it calls pass, otherwise it calls fail.
# Return the issue_id just created or edited if successful, otherwise an empty string.
proc edit_or_add_issue { test myiss myshow issue_id } {
    upvar $myiss iss
    upvar $myshow show
    global Id

    expect {
        -ex "Title ($show(title)): " { send "$iss(title)\n"; exp_continue }
        -ex "Type ($show(type)) \[b/f\]: "
            { send "[string index $iss(type) 0]\n"; exp_continue }
        -ex "Severity ($show(severity)) \[h/m/l\]: "
            { send "[string index $iss(severity) 0]\n"; exp_continue }
        -ex "Reported From ($show(author)): "	{ send "$iss(author)\n"; exp_continue }
        -ex "Assigned To ($show(assign)): "	{ send "$iss(assign)\n"; exp_continue }
        -re "Status \\($show(status)\\) \\\[.*\\\]: "
            { send "[string index $iss(status) 0]\n"; exp_continue }
        -ex {Description (End with a line containing only '.'):}
            { send "$iss(desc1)\n$iss(desc2)\n.\n"; exp_continue }
        -ex [expr {$issue_id eq {} ? {Create issue (y)? } : {Save changes (y)? }}]
            { send "\n"; exp_continue }
        -re [expr {$issue_id eq {} ? "Created issue: ($Id)" : "Edited issue: ($Id)"}] {
            set issue_id $expect_out(1,string)
            pass $test
            return $issue_id
        }

        timeout     { fail "$test: timeout" }
        eof         { fail "$test: EOF" }
        default     { fail $test }
    }

    return {}
}

# Expect block for the `git issius show` command.
# myshow is a reference to the values expected to be output by the command.
# If all is true, it expects the output of `git issius show --all`.
# If successful, it calls pass, otherwise it calls fail.
proc show_issue {test myshow issue_id all} {
    upvar $myshow show
    global C

    set issue_template "^${C}Id$C:$C $C$issue_id$C\r
${C}Title$C:$C $C$show(title)$C\r
${C}Type$C:$C $C[string totitle $show(type)]$C\r
${C}Severity$C:$C $C[string totitle $show(severity)]$C\r
${C}Reported From$C:$C ${C}$show(author)$C\r
${C}Assigned To$C:$C ${C}$show(assign)$C\r
${C}Created On$C:$C ${C}.*$C\r
${C}Updated On$C:$C ${C}.*$C\r
${C}Status$C:$C $C[string totitle $show(status)]$C\r
${C}Description$C:$C\r
  $C$show(desc1)$C\r
  $C$show(desc2)$C\r
"

    if {$all} {
        set issue_template [string cat $issue_template \
"${C}-----$C\r
${C}Reported From$C:$C ${C}$show(comment_author)$C\r
${C}Created On$C:$C ${C}.*$C\r
${C}Description$C:$C\r
  $C$show(comment1)$C\r
  $C$show(comment2)$C\r
${C}-----$C\r
"]
    }

    expect {
        -re "$issue_template" {pass $test}

        timeout     { fail "$test: timeout" }
        eof         { fail "$test: EOF" }
        default     { fail $test }
    }
}

# Expect block for the `git issius list` command.
# myshow is a reference to the values expected to be output by the command.
# If successful, it calls pass, otherwise it calls fail.
proc list_issues {test show_dict {total {}}} {
    global C

    set SEP {\s+\|\s+} ;# field sepatator: " | "

    set listing_header "${C}ID${C}${SEP}${C}Title${C}${SEP}${C}Assigned To${C}${SEP}${C}Type${C}${SEP}${C}Status${C}"

    if {$total eq {}} {
        set total ".*"
    }

    set listing_footer "${C}Total Issues: $total$C\r"

# TODO match assigned partially if $COLUMNS=82, change $show(assign) in test edit

    set issue_template [string map {"\n" ""} "
${C}(\[0-9a-f\]{5})$C
$SEP${C}(.*?)$C
$SEP${C}(.*?)$C
$SEP${C}(.*?)$C
$SEP${C}(\[^\r\]*?)($C|\\s)*\r
"]

    expect_after {
        timeout         { fail "$test: timeout" }
        eof             { fail "$test: EOF" }
        default         { fail $test }
    }

    expect -re "$listing_header" {
        if {[dict size $show_dict] == 0} {
            expect -re "$listing_footer" { pass $test }
        } else {
            dict for {issue_id show} $show_dict {
                expect {
                    -re "$issue_template" {
                        set got_id $expect_out(1,string)
                        if {$got_id eq [string range $issue_id 0 4]} {
                            dict with show {
                                set got_title   $expect_out(2,string)
                                set got_assign  $expect_out(3,string)
                                set got_type    $expect_out(4,string)
                                set got_status  $expect_out(5,string)
                                if {[string first $got_title $title] != 0} {
                                    fail "$test: title mismatch"
                                } elseif {$got_assign ne $assign} {
                                    fail "$test: assigned mismatch, got $got_assign, expected $assign"
                                } elseif {$got_type ne [string totitle $type]} {
                                    fail "$test: type mismatch, got $got_type, expected $type"
                                } elseif {$got_status ne [string totitle $status]} {
                                    fail "$test: status mismatch, got $got_status, expected $status"
                                } else {
                                    exp_continue
                                }
                            }
                        }
                    }
                    -re "$listing_footer" {
                        pass $test
                        break
                    }
                }
            }
        }
    }

    # clean up, ignore errors if the spawned id is already closed (because of
    # nested expect commands)
    catch expect_after
}

# Expect block for `git issius delete`.
# myshow is a reference to the values expected to be prompted by the command.
# If successful, it calls pass, otherwise it calls fail.
# Return the issue_id just deleted if successful, otherwise an empty string.
proc delete_issue {test myshow issue_id} {
    upvar $myshow show
    global C

    set result {}

    expect_after {
        timeout         { fail "$test: timeout" }
        eof             { fail "$test: EOF" }
        default         { fail $test }
    }

    expect -re "Delete issue '$show(title)' \\(y\\)\\? " {
        send "y\n"
        expect -re "${C}Deleted issue$C: $issue_id" {
            pass $test
            set result $issue_id
        }
    }

    catch expect_after ;# clean up

    return $result
}

##############################################################################

# Just to warm up and load python and all needed libraries
set test "version"
spawn $PYTHON $GI
expect {
    -re "Gitissius v.*"	{ pass $test }

    timeout     { fail "$test: timeout" }
    eof         { fail "$test: EOF" }
    default     { fail $test }
}

# Now that python is loaded we can reduce the timeout.
set timeout 3

##############################################################################

# The iss array contains the issue values entered on `git issius add`
# or `edit`.
# Empty strings are used to accept default values.
set iss(title)      {this is the issue title. It is so long that it will be trimmed by `git issius list`}
set iss(severity)   {}
set iss(type)       {}
set iss(author)     {Donald Duck <donald@example.com}
set iss(assign)     {}
set iss(status)     {}
set iss(desc1)      {this is the first line of the issue description}
set iss(desc2)      {this is the second line of the issue description}

# The show array contains the issue values shown on the `git issius add`
# or `edit` prompts and `show` and `list` commands.
# The values will be transformed as needed, e.g. capitalized.
set show(title)      {None}
set show(severity)   {low}
set show(type)       {bug}
set show(author)     {Micky Mouse <micky.mouse@example.com>}
set show(assign)     {None}
set show(status)     {new}

set test "add issue"
spawn $PYTHON $GI add
set result [edit_or_add_issue $test iss show ""]
if {$result ne ""} {set issue_id $result}

##############################################################################

set show(title)      $iss(title)
set show(author)     $iss(author)
set show(desc1)      $iss(desc1)
set show(desc2)      $iss(desc2)

set test "show issue"
if {![info exists issue_id]} {
    unresolved $test
} else {
    spawn $PYTHON $GI show $issue_id
    show_issue $test show $issue_id false
}

##############################################################################

set iss(comment_author) {}
set iss(comment1)      {this is the first line of the issue comment}
set iss(comment2)      {this is the second line of the issue comment}

set show(comment_author) {Micky Mouse <micky.mouse@example.com>}

set test "add issue comment"
if {![info exists issue_id]} {
    unresolved $test
} else {
    spawn $PYTHON $GI comment $issue_id

    expect_after {
        timeout         { fail "$test: timeout" }
        eof             { fail "$test: EOF" }
        default         { fail $test }
    }

    expect -re "${C}Commenting on:$C ${C}$show(title)$C" {
        expect -ex "Reported From \($show(comment_author)\): " {
            send "$iss(comment_author)\n"
            expect -ex {Description (End with a line containing only '.'): } {
                send "$iss(comment1)\n$iss(comment2)\n.\n"
                expect -ex "Comment issue: $issue_id" { pass $test }
            }
        }
    }

    catch expect_after ;# clean up
}

##############################################################################

set show(comment1) $iss(comment1)
set show(comment2) $iss(comment2)

set test "show issue with comments"
if {![info exists issue_id]} {
    unresolved $test
} else {
    spawn $PYTHON $GI show --all $issue_id
    show_issue $test show $issue_id true
}

##############################################################################

set test "list issues"
if {![info exists issue_id]} {
    unresolved $test
} else {
    set show_dict [dict create]
    dict append show_dict $issue_id [dict create {*}[array get show]]]
    spawn $PYTHON $GI list
    list_issues $test $show_dict
}

##############################################################################

set iss(severity)   {high}
set iss(assign)     {Micky Mouse <micky.mouse@example.com>}
set iss(status)     {assigned}

set test "edit issue"
if {![info exists issue_id]} {
    unresolved $test
} else {
    spawn $PYTHON $GI edit $issue_id
    edit_or_add_issue $test iss show $issue_id
}

##############################################################################

set show(severity)   $iss(severity)
set show(assign)     $iss(assign)
set show(status)     $iss(status)

set test "show edited issue (with comments)"
if {![info exists issue_id]} {
    unresolved $test
} else {
    spawn $PYTHON $GI show --all $issue_id
    show_issue $test show $issue_id true
}

##############################################################################

set test "my issues"
if {![info exists issue_id]} {
    unresolved $test
} else {
    set show_dict [dict create]
    dict append show_dict $issue_id [dict create {*}[array get show]]]
    spawn $PYTHON $GI my
    list_issues $test $show_dict 1
}

##############################################################################

set iss2(title)     {this is the second issue}
set iss2(severity)  {high}
set iss2(type)      {feature}
set iss2(author)    {Donald Duck <donald@example.com}
set iss2(assign)    {}
set iss2(status)    {}
set iss2(desc1)     {this is the first line of the issue description}
set iss2(desc2)     {this is the second line of the issue description}

set show2(title)    {None}
set show2(severity) {low}
set show2(type)     {bug}
set show2(author)   {Micky Mouse <micky.mouse@example.com>}
set show2(assign)   {None}
set show2(status)   {new}

set test "add second issue"
spawn $PYTHON $GI add
set result [edit_or_add_issue $test iss2 show2 ""]
if {$result ne ""} {set issue_id2 $result}

##############################################################################

set show2(title)    $iss2(title)
set show2(severity) $iss2(severity)
set show2(type)     $iss2(type)
set show2(author)   $iss2(author)
set show2(desc1)    $iss2(desc1)
set show2(desc2)    $iss2(desc2)

set test "show second issue"
if {![info exists issue_id2]} {
    unresolved $test
} else {
    spawn $PYTHON $GI show $issue_id2
    show_issue $test show2 $issue_id2 false
}

##############################################################################

set test "my issues (only one of the two issues of the database)"
if {![info exists issue_id]} {
    unresolved $test
} else {
    set show_dict [dict create]
    dict append show_dict $issue_id [dict create {*}[array get show]]]
    spawn $PYTHON $GI my
    list_issues $test $show_dict 1
}

##############################################################################

set test "delete issue"
if {![info exists issue_id]} {
    unresolved $test
} else {
    spawn $PYTHON $GI delete $issue_id
    set result [delete_issue $test show $issue_id]
    if {$result ne ""} { unset issue_id }
}

##############################################################################

set test "delete second issue"
if {![info exists issue_id2]} {
    unresolved $test
} else {
    spawn $PYTHON $GI delete $issue_id2
    set result [delete_issue $test show2 $issue_id2]
    if {$result ne ""} { unset issue_id2 }
}

##############################################################################
set test "list issues (empty list)"

if {[info exists issue_id] || [info exists issue_id2]} {
    unresolved $test
} else {
    spawn $PYTHON $GI list
    list_issues $test [dict create] 0
}

##############################################################################
