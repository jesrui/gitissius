set timeout 30

# regexp for the issue id
set Id {[0-9a-f]{64}}
# regexp that match any number of consecutive ANSI color escape sequences from colorama
set C {(?:\e\[[0-9;]*m)*}

# Expect block for `git issius add` and `git issius edit`.
# Execute an `add` command if $iss(id) is empty, `edit` if it is not empty.
# myiss is a reference to the values to be entered for the issue.
# myshow is a reference to the values expected to be prompted by the command.
# If successful, it calls pass, otherwise it calls fail.
# Return the issue id just created or edited if successful, otherwise an empty string.
proc edit_or_add_issue { test myiss myshow } {
    upvar $myiss iss
    upvar $myshow show
    global Id

    set is_add [expr {[array get iss id] == {}}]

    expect {
        -ex "Title ($show(title)): " { send "$iss(title)\n"; exp_continue }
        -ex "Type ($show(type)) \[b/f\]: "
            { send "[string index $iss(type) 0]\n"; exp_continue }
        -ex "Severity ($show(severity)) \[h/m/l\]: "
            { send "[string index $iss(severity) 0]\n"; exp_continue }
        -ex "Reported From ($show(author)): "	{ send "$iss(author)\n"; exp_continue }
        -ex "Assigned To ($show(assign)): "	{ send "$iss(assign)\n"; exp_continue }
        -re "Status \\($show(status)\\) \\\[.*\\\]: "
            { send "[string index $iss(status) 0]\n"; exp_continue }
        -ex {Description (End with a line containing only '.'):}
            { send "$iss(desc1)\n$iss(desc2)\n.\n"; exp_continue }
        -ex [expr {$is_add ? {Create issue (y)? } : {Save changes (y)? }}]
            { send "\n"; exp_continue }
        -re [expr {$is_add ? "Created issue: ($Id)" : "Edited issue: ($Id)"}] {
            set issue_id $expect_out(1,string)
            pass $test
            return $issue_id
        }

        timeout     { fail "$test: timeout" }
        eof         { fail "$test: EOF" }
        default     { fail $test }
    }

    # TODO check that all issue fields in show
    # were seen correctly

    return {}
}

# Expect block for the `git issius show` command.
# myshow is a reference to the values expected to be output by the command.
# If all is true, it expects the output of `git issius show --all`.
# If successful, it calls pass, otherwise it calls fail.
proc show_issue {test myshow all} {
    upvar $myshow show
    global C

    set issue_template "^${C}Id$C:$C $C$show(id)$C\r
${C}Title$C:$C $C$show(title)$C\r
${C}Type$C:$C $C[string totitle $show(type)]$C\r
${C}Severity$C:$C $C[string totitle $show(severity)]$C\r
${C}Reported From$C:$C ${C}$show(author)$C\r
${C}Assigned To$C:$C ${C}$show(assign)$C\r
${C}Created On$C:$C ${C}.*$C\r
${C}Updated On$C:$C ${C}.*$C\r
${C}Status$C:$C $C[string totitle $show(status)]$C\r
${C}Description$C:$C\r
  $C$show(desc1)$C\r
  $C$show(desc2)$C\r
"

    if {$all} {
        set issue_template [string cat $issue_template \
"${C}-----$C\r
${C}Reported From$C:$C ${C}$show(comment_author)$C\r
${C}Created On$C:$C ${C}.*$C\r
${C}Description$C:$C\r
  $C$show(comment1)$C\r
  $C$show(comment2)$C\r
${C}-----$C\r
"]
    }

    expect {
        -re "$issue_template" {pass $test}

        timeout     { fail "$test: timeout" }
        eof         { fail "$test: EOF" }
        default     { fail $test }
    }
}

# Expect block for the `git issius list` command.
# show_dict is a dictionary where the keys are the issues ids to be listed and
# each value is a dictionary with the corresponding issue values
# (with the same structure as the show array).
# total is the expected total number of issues listed.
# If successful, it calls pass, otherwise it calls fail.
proc list_issues {test show_dict {total {}}} {
    global C

    set S {\s+\|\s+} ;# field sepatator: " | "

    set listing_header "${C}ID${C}${S}${C}Title${C}${S}${C}Assigned To${C}${S}${C}Type${C}${S}${C}Status${C}"

    if {$total eq {}} {
        set total ".*"
    }

    set listing_footer "${C}Total Issues: $total$C\r"

# TODO match assigned partially if $COLUMNS=82, change $show(assign) in test edit

    set F {([^\r]+?)} ;# A field value in a row of the listing
    set Fc "${S}${C}${F}${C}" ;# A complete field cell, including separator and value
    set issue_template "${C}(\[0-9a-f\]{5})${C}${Fc}${Fc}${Fc}${Fc}(?:(${C}|\\s))*\r"

    # the same as show_id but using short issue ids
    set sid_dict [dict create]
    dict for {issue_id show} $show_dict {
        dict append sid_dict [string range $issue_id 0 4] $show
    }

#    puts "$test sid_dict $sid_dict"

    expect_after {
        timeout         { fail "$test: timeout" }
        eof             { fail "$test: EOF" }
        default         { fail $test }
    }

    expect -re "$listing_header" {
        if {[dict size $show_dict] == 0} {
            expect -re "$listing_footer" { pass $test }
        } else {
            expect {
                -re "$issue_template" {
                    set got_id $expect_out(1,string)
                    if {[dict exists $sid_dict $got_id]} {
                        dict with sid_dict $got_id {
                            set got_title   $expect_out(2,string)
                            set got_assign  $expect_out(3,string)
                            set got_type    $expect_out(4,string)
                            set got_status  $expect_out(5,string)
                            if {[string first $got_title $title] != 0} {
                                fail "$test: title mismatch"
                            } elseif {$got_assign ne $assign} {
                                fail "$test: assigned mismatch, got $got_assign, expected $assign"
                            } elseif {$got_type ne [string totitle $type]} {
                                fail "$test: type mismatch, got $got_type, expected $type"
                            } elseif {$got_status ne [string totitle $status]} {
                                fail "$test: status mismatch, got $got_status, expected $status"
                            } else {
                                exp_continue
                            }
                        }
                    } else {
                        fail "$test unexpected issue id $got_id found in the list"
                    }
                }
                -re "$listing_footer" {
                    # TODO check that all issue ids in show_dict
                    # were seen correctly
                    pass $test
                }
            }
        }
    }

    # clean up, ignore errors if the spawned id is already closed (because of
    # nested expect commands)
    catch expect_after
}

# Expect block for `git issius delete`.
# myshow is a reference to the values expected to be prompted by the command.
# If successful, it calls pass, otherwise it calls fail.
# Return an empty string if successful, otherwise $show(id)
proc delete_issue {test myshow} {
    upvar $myshow show
    global C

    set result $show(id)

    expect_after {
        timeout         { fail "$test: timeout" }
        eof             { fail "$test: EOF" }
        default         { fail $test }
    }

    expect -re "Delete issue '$show(title)' \\(y\\)\\? " {
        send "y\n"
        expect -re "${C}Deleted issue$C: $show(id)" {
            pass $test
            set result {}
        }
    }

    catch expect_after ;# clean up

    return $result
}

##############################################################################

# Just to warm up and load python and all needed libraries
set test "version"
spawn $PYTHON $GI
expect {
    -re "Gitissius v.*"	{ pass $test }

    timeout     { fail "$test: timeout" }
    eof         { fail "$test: EOF" }
    default     { fail $test }
}

# Now that python is loaded we can reduce the timeout.
set timeout 3

##############################################################################

# The iss array contains the issue values entered on `git issius add`
# or `edit`.
# Empty strings are used to accept default values.
set iss(title)      {this is the issue title. It is so long that it will be trimmed by `git issius list`}
set iss(severity)   {}
set iss(type)       {}
set iss(author)     {Donald Duck <donald@example.com}
set iss(assign)     {}
set iss(status)     {}
set iss(desc1)      {this is the first line of the issue description}
set iss(desc2)      {this is the second line of the issue description}

# The show array contains the issue values shown on the `git issius add`
# or `edit` prompts and `show` and `list` commands.
# The values will be transformed as needed, e.g. capitalized.
set show(title)      {None}
set show(severity)   {low}
set show(type)       {bug}
set show(author)     {Micky Mouse <micky.mouse@example.com>}
set show(assign)     {None}
set show(status)     {new}

set test "add issue"
spawn $PYTHON $GI add
set iss(id) [edit_or_add_issue $test iss show]

##############################################################################

set show(id)         $iss(id)
set show(title)      $iss(title)
set show(author)     $iss(author)
set show(desc1)      $iss(desc1)
set show(desc2)      $iss(desc2)

set test "show issue"
if {$show(id) eq {}} {
    unresolved $test
} else {
    spawn $PYTHON $GI show $show(id)
    show_issue $test show false
}

##############################################################################

set iss(comment_author) {}
set iss(comment1)      {this is the first line of the issue comment}
set iss(comment2)      {this is the second line of the issue comment}

set show(comment_author) {Micky Mouse <micky.mouse@example.com>}

set test "add issue comment"
if {$show(id) eq {}} {
    unresolved $test
} else {
    spawn $PYTHON $GI comment $show(id)

    expect_after {
        timeout         { fail "$test: timeout" }
        eof             { fail "$test: EOF" }
        default         { fail $test }
    }

    expect -re "${C}Commenting on:$C ${C}$show(title)$C" {
        expect -ex "Reported From \($show(comment_author)\): " {
            send "$iss(comment_author)\n"
            expect -ex {Description (End with a line containing only '.'): } {
                send "$iss(comment1)\n$iss(comment2)\n.\n"
                expect -ex "Comment issue: $show(id)" { pass $test }
            }
        }
    }

    catch expect_after ;# clean up
}

##############################################################################

set show(comment1) $iss(comment1)
set show(comment2) $iss(comment2)

set test "show issue with comments"
if {$show(id) eq {}} {
    unresolved $test
} else {
    spawn $PYTHON $GI show --all $show(id)
    show_issue $test show true
}

##############################################################################

set test "list issues (only one issue)"
if {$show(id) eq {}} {
    unresolved $test
} else {
    set show_dict [dict create]
    dict append show_dict $show(id) [dict create {*}[array get show]]
    spawn $PYTHON $GI list
    list_issues $test $show_dict
}

##############################################################################

set iss(severity)   {high}
set iss(assign)     {Micky Mouse <micky.mouse@example.com>}
set iss(status)     {assigned}

set test "edit issue"
if {$show(id) eq {}} {
    unresolved $test
} else {
    spawn $PYTHON $GI edit $show(id)
    edit_or_add_issue $test iss show
}

##############################################################################

set show(severity)   $iss(severity)
set show(assign)     $iss(assign)
set show(status)     $iss(status)

set test "show edited issue (with comments)"
if {$show(id) eq {}} {
    unresolved $test
} else {
    spawn $PYTHON $GI show --all $show(id)
    show_issue $test show true
}

##############################################################################

set test "my issues"
if {$show(id) eq {}} {
    unresolved $test
} else {
    set show_dict [dict create]
    dict append show_dict $show(id) [dict create {*}[array get show]]
    spawn $PYTHON $GI my
    list_issues $test $show_dict 1
}

##############################################################################

set iss2(title)     {this is the second issue}
set iss2(severity)  {medium}
set iss2(type)      {feature}
set iss2(author)    {}
set iss2(assign)    {}
set iss2(status)    {}
set iss2(desc1)     {this is the first line of the description of the second issue}
set iss2(desc2)     {this is the second line of the description of the second issue}

set show2(title)    {None}
set show2(severity) {low}
set show2(type)     {bug}
set show2(author)   {Micky Mouse <micky.mouse@example.com>}
set show2(assign)   {None}
set show2(status)   {new}

set test "add second issue"
# TODO sleep 1 (after 1000) to ensure that iss and iss2 have different created_on and updated_on values
spawn $PYTHON $GI add
set iss2(id) [edit_or_add_issue $test iss2 show2]

##############################################################################

set show2(id)       $iss2(id)
set show2(title)    $iss2(title)
set show2(severity) $iss2(severity)
set show2(type)     $iss2(type)
set show2(desc1)    $iss2(desc1)
set show2(desc2)    $iss2(desc2)

set test "show second issue"
if {$show2(id) eq {}} {
    unresolved $test
} else {
    spawn $PYTHON $GI show $show2(id)
    show_issue $test show2 false
}

##############################################################################

set test "list issues (two issues in the database)"
if {$show(id) eq {} || $show2(id) eq {}} {
    unresolved $test
} else {
    set show_dict [dict create]
    dict append show_dict $show(id) [dict create {*}[array get show]]
    dict append show_dict $show2(id) [dict create {*}[array get show2]]
    spawn $PYTHON $GI list
    list_issues $test $show_dict 2
}

##############################################################################

set test "my issues (only one of the two issues of the database)"
if {$show(id) eq {}} {
    unresolved $test
} else {
    set show_dict [dict create]
    dict append show_dict $show(id) [dict create {*}[array get show]]
    spawn $PYTHON $GI my
    list_issues $test $show_dict 1
}

##############################################################################

set test "list --filter=id (substring)"
if {$show(id) eq {}} {
    unresolved $test
} else {
    set show_dict [dict create]
    dict append show_dict $show(id) [dict create {*}[array get show]]
    spawn $PYTHON $GI list --filter=id:[string range $show(id) 10 20]
    list_issues $test $show_dict 1
}

##############################################################################

set filter_by "
assigned_to assigned_to__exact assigned_to__not assigned_to__startwith
id id__exact id__not id__startswith
reported_from reported_from__exact reported_from__not reported_from__startswith
status status__exact status__not status__startswith title
title__exact title__not title__startswith type
type__exact type__not type__startswith
"
# TODO check
# created_on created_on__exact created_on__not created_on__startswith
# XXX typo: s/updated_to/updated_on/
# updated_to updated_to__exact updated_to__not updated_to__startswith

foreach f $filter_by {
#    puts "filter '$f'"

    set test "list --filter=$f"
    if {$show(id) eq {} || $show2(id) eq {}} {
        unresolved $test
        continue
    }

    # The expected show array is either show or show2 depending on the filter
    # ending.
    if {[string first __not $f] == -1 } {
        array set expected [array get show]
    } else {
        array set expected [array get show2]
    }
#    puts "$test expected [array get expected]"

    # Map filter names to show array names
    regsub "__.*$" $f {} tag
    switch "$tag" {
        assigned_to {set tag assign}
        reported_from {set tag author}
    }

    # launch `git issius list` command and check output 
    set show_dict [dict create]
    dict append show_dict $expected(id) [dict create {*}[array get expected]]
#    puts "$test tag $tag show_dict $show_dict"
    spawn $PYTHON $GI list --filter=$f:$show($tag)
    list_issues $test $show_dict 1
}

##############################################################################

set test "delete issue"
if {$show(id) eq {}} {
    unresolved $test
} else {
    spawn $PYTHON $GI delete $show(id)
    set iss(id) [delete_issue $test show]
    set show(id) $iss(id)
}

##############################################################################

set test "delete second issue"
if {$show2(id) eq {}} {
    unresolved $test
} else {
    spawn $PYTHON $GI delete $show2(id)
    set iss2(id) [delete_issue $test show2]
    set show2(id) $iss2(id)
}

##############################################################################
set test "list issues (empty list)"

if {$show(id) ne {} || $show2(id) ne {}} {
    unresolved $test
} else {
    spawn $PYTHON $GI list
    list_issues $test [dict create] 0
}

##############################################################################
